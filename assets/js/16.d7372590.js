(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{344:function(t,e,r){"use strict";r.r(e);var a=r(4),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"pytorch-图像模型入门-timm-从业者指南"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pytorch-图像模型入门-timm-从业者指南"}},[t._v("#")]),t._v(" PyTorch 图像模型入门 (timm)：从业者指南")]),t._v(" "),e("p",[t._v("如何在您自己的训练脚本中使用这个出色的库\n"),e("a",{attrs:{href:"https://towardsdatascience.com/getting-started-with-pytorch-image-models-timm-a-practitioners-guide-4e77b4bf9055",target:"_blank",rel:"noopener noreferrer"}},[e("strong",[t._v("转载链接")]),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/rwightman/pytorch-image-models",target:"_blank",rel:"noopener noreferrer"}},[t._v("PyTorch Image Models (timm)"),e("OutboundLink")],1),t._v("是一个用于最先进图像分类的库，包含图像模型、优化器、调度器、增强等的集合；它最近被评为"),e("a",{attrs:{href:"https://medium.com/paperswithcode/papers-with-code-2021-a-year-in-review-de75d5a77b8b",target:"_blank",rel:"noopener noreferrer"}},[t._v("2021 年带代码论文的热门图书馆"),e("OutboundLink")],1),t._v("！")]),t._v(" "),e("p",[t._v("虽然有越来越多的低代码和无代码解决方案可以很容易地开始将深度学习应用于计算机视觉问题，但在我目前作为 Microsoft CSE 的一员的角色中，我们经常与希望寻求量身定制的定制解决方案的客户打交道针对他们的具体问题；利用最新和最伟大的创新来超越这些服务提供的性能水平。由于新架构和培训技术被引入这个快速发展的领域的速度，无论您是初学者还是专家，都可能很难跟上最新的实践，并且在接触新事物时不知道从哪里开始变得具有挑战性视觉任务，目的是重现与学术基准中呈现的结果相似的结果。")]),t._v(" "),e("p",[t._v("无论我是从头开始训练，还是针对新任务微调现有模型，以及希望利用预先存在的组件来加快我的工作流程，timm 都是我最喜欢的 PyTorch 计算机视觉库之一。然而，虽然 timm 包含用于重现"),e("a",{attrs:{href:"https://www.image-net.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ImageNet训练结果的参考"),e("OutboundLink")],1),e("a",{attrs:{href:"https://github.com/rwightman/pytorch-image-models/blob/master/train.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("训练"),e("OutboundLink")],1),t._v("和"),e("a",{attrs:{href:"https://github.com/rwightman/pytorch-image-models/blob/master/validate.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("验证脚本，并且"),e("OutboundLink")],1),e("a",{attrs:{href:"https://rwightman.github.io/pytorch-image-models/",target:"_blank",rel:"noopener noreferrer"}},[t._v("在官方文档"),e("OutboundLink")],1),t._v("和"),e("a",{attrs:{href:"https://fastai.github.io/timmdocs/",target:"_blank",rel:"noopener noreferrer"}},[t._v("timmdocs 项目"),e("OutboundLink")],1),t._v("中有涵盖核心组件的文档，但由于库提供的功能数量庞大，可能很难知道在哪里在自定义用例中应用这些时开始。"),e("a",{attrs:{href:"https://www.image-net.org/",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1),e("a",{attrs:{href:"https://rwightman.github.io/pytorch-image-models/",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1),e("a",{attrs:{href:"https://fastai.github.io/timmdocs/",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("本指南的目的是从从业者的角度探索 timm，重点介绍如何在自定义训练脚本中使用 timm 中包含的一些功能和组件。重点不是探索这些概念如何或为什么起作用，或者它们是如何在 timm 中实现的；为此，将在适当的地方提供原始论文的链接，我会推荐"),e("a",{attrs:{href:"https://fastai.github.io/timmdocs/",target:"_blank",rel:"noopener noreferrer"}},[t._v("timmdocs"),e("OutboundLink")],1),t._v("以了解有关 timm 内部结构的更多信息。此外，本文绝不是详尽无遗的，选择的领域是基于我使用这个库的个人经验。")]),t._v(" "),e("p",[t._v("此处的所有信息均基于"),e("code",[t._v("timm==0.5.4")]),t._v("撰写本文时最近发布的信息。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/d3d518dc40725ad8741f3232fc773e09.jpeg",alt:""}})]),t._v(" "),e("p",[e("a",{attrs:{href:"https://unsplash.com/@cgower",target:"_blank",rel:"noopener noreferrer"}},[t._v("Christopher Gower"),e("OutboundLink")],1),t._v("在"),e("a",{attrs:{href:"https://unsplash.com/photos/m_HRfLhgABo",target:"_blank",rel:"noopener noreferrer"}},[t._v("Unsplash"),e("OutboundLink")],1),t._v("上的图片"),e("a",{attrs:{href:"https://unsplash.com/photos/m_HRfLhgABo",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("虽然可以按顺序阅读这篇文章，但它也可以作为图书馆特定部分的参考。为了便于导航，下面提供了目录。")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#b83b"}},[e("strong",[t._v("模型")])]),e("a",{attrs:{href:"#983b"}},[e("br")]),t._v("-"),e("a",{attrs:{href:"#9388"}},[t._v("自定义模型")]),e("br"),t._v("\n-"),e("a",{attrs:{href:"#0583"}},[t._v("特征提取")]),e("br"),t._v("\n-"),e("a",{attrs:{href:"#c193"}},[t._v("导出为不同格式")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#4cc7"}},[e("strong",[t._v("数据增强")])]),t._v("- "),e("a",{attrs:{href:"#8549"}},[t._v("RandAugment")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#e618"}},[t._v("CutMix 和 MixUp")])])])]),t._v(" "),e("li",[e("a",{attrs:{href:"#c725"}},[e("strong",[t._v("数据集")])]),e("br"),t._v("\n-"),e("a",{attrs:{href:"#2c65"}},[t._v("从 TorchVision")]),e("br"),t._v("\n加载数据集-"),e("a",{attrs:{href:"#96e0"}},[t._v("从 TensorFlow")]),e("br"),t._v("\n加载数据集 数​​据集-"),e("a",{attrs:{href:"#03bd"}},[t._v("从本地文件夹加载数据集")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#a4d1"}},[t._v("ImageDataset 类")])])])]),t._v(" "),e("li",[e("a",{attrs:{href:"#18f9"}},[e("strong",[t._v("优化器")])]),e("br"),t._v("\n-"),e("a",{attrs:{href:"#5e2d"}},[t._v("使用示例")]),e("br"),t._v("\n-"),e("a",{attrs:{href:"#0afa"}},[t._v("前瞻")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#50f2"}},[e("strong",[t._v("调度程序")])]),t._v("-"),e("a",{attrs:{href:"#9ad3"}},[t._v("使用示例")]),e("br"),t._v("\n-"),e("a",{attrs:{href:"#65e2"}},[t._v("调整学习率计划")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#429c"}},[e("strong",[t._v("指数移动平均模型")])])]),t._v(" "),e("li",[e("a",{attrs:{href:"#901e"}},[e("strong",[t._v("把它们放在一起！")])])])]),t._v(" "),e("p",[e("strong",[e("em",[t._v("Tl;dr：")])]),e("em",[t._v("如果您只想查看一些可以直接使用的工作代码，复制这篇文章所需的所有代码都可以在")]),e("a",{attrs:{href:"https://gist.github.com/Chris-hughes10/a9e5ec2cd7e7736c651bf89b5484b4a9",target:"_blank",rel:"noopener noreferrer"}},[e("em",[t._v("此处作为 GitHub 要点")]),e("OutboundLink")],1),e("em",[t._v("获得。")])]),t._v(" "),e("p",[t._v("timm 最受欢迎的功能之一是其庞大且不断增长的模型架构集合。其中许多模型包含预训练的权重——要么在 PyTorch 中进行本地训练，要么从其他库（如 Jax 和 TensorFlow）移植——可以轻松下载和使用。")]),t._v(" "),e("p",[t._v("我们可以列出和查询集合可用模型，如下所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/11486427de0829bc74975a4e2606c6a3.png",alt:""}})]),t._v(" "),e("p",[t._v("我们还可以使用_预训练_参数将此选择过滤为具有预训练权重的模型：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/3beb0f2c86f9c6ebe747089cd25d5c90.png",alt:""}})]),t._v(" "),e("p",[t._v("这仍然是一个令人印象深刻的数字！如果此时您遇到一点选项瘫痪，请不要绝望！"),e("a",{attrs:{href:"https://paperswithcode.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Papers with code的"),e("OutboundLink")],1),e("a",{attrs:{href:"https://paperswithcode.com/lib/timm",target:"_blank",rel:"noopener noreferrer"}},[t._v("这个摘要页面"),e("OutboundLink")],1),t._v("是一个有用的资源，可用于探索一些可用的模型并了解它们的性能，其中包含 timm 中包含的许多模型的基准和原始论文的链接。"),e("a",{attrs:{href:"https://paperswithcode.com/",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("为简单起见，让我们在这里坚持使用熟悉的、久经考验的 ResNet 模型系列。我们可以通过提供通配符字符串来列出可用的不同 ResNet 变体，该字符串将用作基于模型名称的过滤器：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/000a8205d48b333ec4200abae2597bbb.png",alt:""}})]),t._v(" "),e("p",[t._v("正如我们所看到的，仍然有很多选择！现在，让我们探讨一下如何从这个列表中创建模型。")]),t._v(" "),e("h2",{attrs:{id:"一般用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一般用法"}},[t._v("#")]),t._v(" 一般用法")]),t._v(" "),e("p",[t._v("创建模型的最简单方法是使用"),e("code",[t._v("create_model")]),t._v("; 可用于在 timm 库中创建任何模型的工厂函数。")]),t._v(" "),e("p",[t._v("让我们通过创建一个 Resnet-D 模型来证明这一点，正如"),e("a",{attrs:{href:"https://arxiv.org/abs/1812.01187",target:"_blank",rel:"noopener noreferrer"}},[t._v("_卷积神经网络图像分类技巧袋论文_中"),e("OutboundLink")],1),t._v("所介绍的那样；这是对 ResNet 架构的修改，它利用平均池调整进行下采样。这在很大程度上是一个随意的选择，此处演示的功能应该适用于 timm 中包含的大多数模型。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/0b63792cd552ff83a191f9b3501b3ccf.png",alt:""}})]),t._v(" "),e("p",[t._v("正如我们所见，这只是一个常规的 PyTorch 模型。")]),t._v(" "),e("p",[t._v("为了帮助我们更多地了解如何使用这个模型，我们可以访问它的配置，其中包含诸如应该用于规范化输入数据的统计信息、输出类的数量和网络分类部分的名称等信息.")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/2eb4c26ac221c451d54e49fb6618923d.png",alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("具有不同数量输入通道的图像的预训练模型")])]),t._v(" "),e("p",[t._v("timm 模型的一个鲜为人知但非常有用的特性是它们能够处理具有不同数量通道的输入图像，这给大多数其他库带来了问题；"),e("a",{attrs:{href:"https://fastai.github.io/timmdocs/models#So-how-is-timm-able-to-load-these-weights?",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),e("OutboundLink")],1),t._v("描述了一个很好的解释这是如何工作的。直观上，timm 通过对少于 3 个通道的初始卷积层的权重求和，或者智能地将这些权重复制到所需数量的通道来做到这一点。")]),t._v(" "),e("p",[t._v("_我们可以通过将in_chans_参数传递给 来指定输入图像的通道数"),e("code",[t._v("create_model")]),t._v("。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/ce541a776b67fc7e60896d185b6daf24.png",alt:""}})]),t._v(" "),e("p",[t._v("在这种情况下使用随机张量表示单通道图像，我们可以看到模型已经处理了图像并返回了预期的输出形状。")]),t._v(" "),e("p",[t._v("重要的是要注意，虽然这使我们能够使用预训练模型，但输入与训练模型的图像有很大不同。因此，我们不应该期待相同水平的性能，并在将模型用于任务之前在新数据集上微调模型！")]),t._v(" "),e("h2",{attrs:{id:"定制模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定制模型"}},[t._v("#")]),t._v(" "),e("strong",[t._v("定制模型")])]),t._v(" "),e("p",[t._v("除了使用库存架构创建模型外，"),e("code",[t._v("create_model")]),t._v("还支持许多参数，使我们能够为我们的任务定制模型。")]),t._v(" "),e("p",[t._v("支持的参数可能取决于底层模型架构，其中一些参数例如：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("global_pool")]),t._v("：确定在最终分类层之前要使用的全局池的类型")])]),t._v(" "),e("p",[t._v("特定于模型。在这种情况下，这取决于架构是否采用全局池化层。因此，虽然我们可以将它与类似 ResNet 的模型一起使用，但将它与不使用平均池化的"),e("a",{attrs:{href:"https://arxiv.org/abs/2010.11929v2",target:"_blank",rel:"noopener noreferrer"}},[t._v("ViT一起使用是没有意义的。"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("虽然有些参数是特定于模型的，但参数例如：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("drop_rate")]),t._v("：设置训练的辍学率（默认值：`0`）")]),t._v(" "),e("li",[e("strong",[t._v("num_classes")]),t._v(" : 类对应的输出神经元数量")])]),t._v(" "),e("p",[t._v("几乎可以用于所有型号。")]),t._v(" "),e("p",[t._v("在我们探索一些我们可以做到这一点的方法之前，让我们检查一下我们当前模型的默认架构。")]),t._v(" "),e("p",[e("strong",[t._v("更改班级数量")])]),t._v(" "),e("p",[t._v("检查我们之前看到的模型配置，我们可以看到我们网络的分类头名称是_fc_。我们可以使用它来直接访问相应的模块。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/4f55717814b5e99b424be3f2f131a2a7.png",alt:""}})]),t._v(" "),e("p",[t._v("但是，这个名称可能会根据所使用的模型架构而改变。为了为不同的模型提供一致的接口，timm 模型有"),e("code",[t._v("get_classifier")]),t._v(" 方法，我们可以使用它来检索分类头，而无需查找模块名称。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/397faad5362a0c6d8666c9758fc9b586.png",alt:""}})]),t._v(" "),e("p",[t._v("正如预期的那样，这将返回与之前相同的线性层。")]),t._v(" "),e("p",[t._v("由于这个模型是在 ImageNet 上预训练的，我们可以看到最后一层输出了 1000 个类。我们可以用_num_classes_参数改变它：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/3a668c26d96e4971ef968d887671acca.png",alt:""}})]),t._v(" "),e("p",[t._v("检查分类器，我们可以看到 timm 已经用一个新的、未经训练的、具有所需类别数量的线性层替换了最后一层；准备微调我们的数据集！")]),t._v(" "),e("p",[t._v("如果我们想避免完全创建最后一层，我们可以将类的数量设置为 0，这将创建一个具有恒等函数的模型作为最后一层；这对于检查倒数第二层的输出很有用。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/343c7fa455fb803fb66cd31096f142cc.png",alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("全局合并选项")])]),t._v(" "),e("p",[t._v("从我们模型的配置中，我们还可以看到_pool_size_已设置，通知我们在分类器之前使用了全局池化层。我们可以按如下方式检查：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/58badf1196cce02790d150838f3b3827.png",alt:""}})]),t._v(" "),e("p",[t._v("在这里，我们可以看到这返回了一个 的实例"),e("code",[t._v("SelectAdaptivePool2d")]),t._v("，它是 timm 提供的自定义层，它支持不同的池化和展平配置。在撰写本文时，支持的池化选项有：")]),t._v(" "),e("ul",[e("li",[e("em",[t._v("avg")]),t._v("：平均池化")]),t._v(" "),e("li",[e("em",[t._v("max")]),t._v(" : 最大池化")]),t._v(" "),e("li",[t._v("_avgmax：_平均池化和最大池化的总和，按 0.5 重新缩放")]),t._v(" "),e("li",[t._v("_catavgmax：_沿特征维度的平均和最大池化输出的串联。请注意，这将使特征维度加倍。")]),t._v(" "),e("li",[t._v("_'' :_没有使用池化，池化层被Identity操作代替")])]),t._v(" "),e("p",[t._v("我们可以可视化不同池化选项的输出形状，如下所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/e20a1f7f61675a36824ebdca8df24be9.png",alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("修改现有模型")])]),t._v(" "),e("p",[t._v("我们还可以使用以下方法修改现有模型的分类器和池化层"),e("code",[t._v("reset_classifier")]),t._v(" ：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/9760579e59605ba99ffa9c1a204f09fb.png",alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("创建一个新的分类头")])]),t._v(" "),e("p",[t._v("虽然已经证明使用单个线性层作为我们的分类器足以获得良好的结果，但在对下游任务微调模型时，我经常发现使用稍大的头部可以提高性能。让我们探索如何进一步修改我们的 ResNet 模型。")]),t._v(" "),e("p",[t._v("首先，让我们像以前一样创建我们的 ResNet 模型，指定我们想要 10 个类。由于我们使用的是更大的头部，因此我们使用_catavgmax_进行池化，以便我们提供更多信息作为分类器的输入。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/d131aaa798d6c417ddd4a035462de608.png",alt:""}})]),t._v(" "),e("p",[t._v("从现有的分类器中，我们可以得到输入特征的数量：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/5d32cf0984095ded9570dc705074397d.png",alt:""}})]),t._v(" "),e("p",[t._v("现在，我们可以通过直接访问分类器，用修改后的分类头替换最后一层。在这里，分类头的选择有些随意。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/c5049489023b64b7d0cd75ea20406c00.png",alt:""}})]),t._v(" "),e("p",[t._v("使用虚拟输入测试模型，我们得到预期形状的输出。现在，我们修改后的模型可以训练了！")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/93ff6a7f7c77ca90ab5a0cd309cf022a.png",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"特征提取"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特征提取"}},[t._v("#")]),t._v(" 特征提取")]),t._v(" "),e("p",[t._v("timm 模型还具有用于获取各种类型的中间特征的一致机制，这对于将架构用作下游任务的特征提取器非常有用；比如"),e("a",{attrs:{href:"https://ieeexplore.ieee.org/document/8099589",target:"_blank",rel:"noopener noreferrer"}},[t._v("在物体检测中创建特征金字塔"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.robots.ox.ac.uk/~vgg/data/pets/",target:"_blank",rel:"noopener noreferrer"}},[t._v("让我们使用来自Oxford pets 数据集"),e("OutboundLink")],1),t._v("的图像可视化这是如何工作的。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/d19e038e9f2614ae3b343bfe26bbbdb0.png",alt:""}})]),t._v(" "),e("p",[t._v("我们可以将其转换为张量，并将通道转置为 PyTorch 期望的格式：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/375090ac979689588232f688806bf083.png",alt:""}})]),t._v(" "),e("p",[t._v("再一次，让我们创建我们的 ResNet-D 模型：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/bff4b23a44080ef22af167a70b1391ec.png",alt:""}})]),t._v(" "),e("p",[t._v("如果我们只对最终的特征图感兴趣——在这种情况下，即池化之前最终卷积层的输出——我们可以使用该"),e("code",[t._v("forward_features")]),t._v(" 方法绕过全局池化层和分类层。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/66edd69cf7f85365daaee10a3848130e.png",alt:""}})]),t._v(" "),e("p",[t._v("我们可以在下面想象一下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/6b35e816dfcd5ff819a565b300cfc060.png",alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("多个特征输出")])]),t._v(" "),e("p",[t._v("虽然前向特征方法可以方便地检索最终特征图，但 timm 还提供了使我们能够使用模型作为特征主干的功能，为选定级别输出特征图。")]),t._v(" "),e("p",[t._v("我们可以通过在创建模型时使用参数_features_only=True_来指定我们希望将模型用作特征主干。默认情况下，大多数模型（并非所有模型都有那么多）将输出 5 个步幅，第一个从 2 开始（但有些从 1 或 4 开始）。")]),t._v(" "),e("p",[t._v("可以使用_out_indices_和_output_stride_参数修改特征级别的索引和步幅数，如"),e("a",{attrs:{href:"https://rwightman.github.io/pytorch-image-models/feature_extraction/#multi-scale-feature-maps-feature-pyramid",target:"_blank",rel:"noopener noreferrer"}},[t._v("文档"),e("OutboundLink")],1),t._v("中所示。")]),t._v(" "),e("p",[t._v("让我们看看它如何与我们的 ResNet-D 模型一起使用。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/fdab1ac95ded8a0fa7b20a8277d144f5.png",alt:""}})]),t._v(" "),e("p",[t._v("如下所示，我们可以获得有关返回的特征的更多信息，例如具体的模块名称、减少的特征和通道数：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/3942fbe1cadb9638a6c81150f7c25606.png",alt:""}})]),t._v(" "),e("p",[t._v("现在，让我们通过特征提取器传递图像并探索输出。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/37d711063df14bca22533a129da48f6c.png",alt:""}})]),t._v(" "),e("p",[t._v("不出所料，返回了 5 个特征图。检查形状，我们可以看到通道数与我们预期的一致：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/761060d0cb9cca9c5c65dfb7b0fe6947.png",alt:""}})]),t._v(" "),e("p",[t._v("可视化每个特征图，我们可以看到图像正在逐渐下采样，正如我们所期望的那样。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/aeb8aecd15f69924090cdc1ee0ffef96.png",alt:""}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/d040212474cf73b3a1f4d60f22038799.png",alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("使用 Torch FX")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://pytorch.org/vision/stable/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("TorchVision"),e("OutboundLink")],1),t._v("最近发布了一个名为 FX 的新实用程序，它使得在 PyTorch 模块的前向传递期间更容易访问输入的中间转换。这是通过象征性地跟踪 forward 方法来生成一个图来完成的，其中每个节点代表一个操作。由于节点被赋予了人类可读的名称，因此很容易准确地指定我们想要访问的节点。"),e("a",{attrs:{href:"https://pytorch.org/docs/stable/fx.html#module-torch.fx",target:"_blank",rel:"noopener noreferrer"}},[t._v("FX在文档"),e("OutboundLink")],1),t._v("和"),e("a",{attrs:{href:"https://pytorch.org/blog/FX-feature-extraction-torchvision/",target:"_blank",rel:"noopener noreferrer"}},[t._v("这篇博"),e("OutboundLink")],1),t._v("文中有更详细的描述。")]),t._v(" "),e("p",[e("strong",[t._v("注意")]),t._v("：在撰写本文时，动态控制流在使用 FX 时还不能用静态图来表示。")]),t._v(" "),e("p",[t._v("由于 timm 中的几乎所有模型都是符号可追溯的，我们可以使用 FX 来操纵这些模型。让我们探索如何使用 FX 从 timm 模型中提取特征。")]),t._v(" "),e("p",[t._v("首先，让我们从 TorchVision 导入一些辅助方法：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/2a63aa02a8a5c1e08fe1fcc2b6bc7631.png",alt:""}})]),t._v(" "),e("p",[t._v("现在，我们重新创建带有分类头的 ResNet-D 模型，并使用_可导出_参数来确保模型是可追踪的。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/2598f412a0ca1dc12b8040682ad0fd6e.png",alt:""}})]),t._v(" "),e("p",[t._v("现在，我们可以使用该"),e("code",[t._v("get_graph_nodes")]),t._v("方法按执行顺序返回节点名称。由于模型被跟踪两次，在训练和评估模式下，都会返回两组节点名称。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/95ad8339cb9d97a640ed1ef1e2d02e0c.png",alt:""}})]),t._v(" "),e("p",[t._v("使用 FX，可以轻松访问来自任何节点的输出。_让我们选择layer1_中的第二个激活。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/c36159f311a0e200cf3a20ea18451229.png",alt:""}})]),t._v(" "),e("p",[t._v("使用"),e("code",[t._v("create_feature_extractor")]),t._v("，我们可以在该点“切割”模型，如下所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/8293ddd4cf162b75342b6e7b7a085e45.png",alt:""}})]),t._v(" "),e("p",[t._v("现在，通过我们的特征提取器传递图像，这将返回一个张量字典。然后我们可以像以前一样将其可视化：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/c8f9271cdec8f3805dd4cfec8b6397e2.png",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"导出为不同格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#导出为不同格式"}},[t._v("#")]),t._v(" 导出为不同格式")]),t._v(" "),e("p",[t._v("训练后，通常建议将模型导出为优化格式以进行推理；PyTorch 有多种选择可以做到这一点。由于几乎所有 timm 模型都是可编写脚本和可跟踪的，因此我们可以使用这些格式。")]),t._v(" "),e("p",[t._v("让我们检查一些可用的选项。")]),t._v(" "),e("p",[e("strong",[t._v("导出到 TorchScript")])]),t._v(" "),e("p",[t._v("TorchScript 是一种从 PyTorch 代码创建可序列化和可优化模型的方法；任何 TorchScript 程序都可以从 Python 进程中保存并加载到没有 Python 依赖性的进程中。")]),t._v(" "),e("p",[t._v("我们可以通过两种不同的方式将模型转换为 TorchScript：")]),t._v(" "),e("ul",[e("li",[e("em",[t._v("Tracing")]),t._v("：运行代码，记录发生的操作并构造包含这些操作的 ScriptModule。控制流或动态行为（如 if/else 语句）被删除。")]),t._v(" "),e("li",[e("em",[t._v("脚本")]),t._v("：使用脚本编译器对 Python 源代码进行直接分析，将其转换为 TorchScript。这保留了动态控制流，并且适用于不同大小的输入。")])]),t._v(" "),e("p",[t._v("有关 TorchScript"),e("a",{attrs:{href:"https://pytorch.org/docs/stable/jit.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("的更多信息，请参阅文档"),e("OutboundLink")],1),t._v("和"),e("a",{attrs:{href:"https://pytorch.org/tutorials/beginner/Intro_to_TorchScript_tutorial.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("本教程"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("p",[t._v("由于大多数 timm 模型都可以编写脚本，因此让我们使用脚本来导出我们的 ResNet-D 模型。我们可以设置层配置，以便在创建我们的模型时使用_脚本化参数对模型进行 jit 脚本化。_")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/598e84cb3af2d76acbffc4adcad6f35b.png",alt:""}})]),t._v(" "),e("p",[t._v("重要的是"),e("code",[t._v("model.eval()")]),t._v("在导出模型之前调用，将模型置于推理模式，因为 dropout 和 batchnorm 等运算符的行为因模式而异。")]),t._v(" "),e("p",[t._v("我们现在可以验证我们是否能够编写脚本并使用我们的模型。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/2365e757f93e7012e8c8672ad59cfed9.png",alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("导出到 ONNX")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://onnx.ai/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Open Neural Network eXchange (ONNX)"),e("OutboundLink")],1),t._v("是一种用于表示机器学习模型的开放标准格式。")]),t._v(" "),e("p",[t._v("我们可以使用该"),e("code",[t._v("torch.onnx")]),t._v("模块将timm模型导出到ONNX；使它们能够被支持 ONNX 的许多运行时中的任何一个使用。如果"),e("code",[t._v("torch.onnx.export()")]),t._v("用一个还不是 ScriptModule 的模块调用，它首先执行等同于"),e("code",[t._v("torch.jit.trace()")]),t._v("; 它使用给定的参数执行一次模型并记录在该执行期间发生的所有操作。这意味着如果模型是动态的，例如，根据输入数据更改行为，则导出的模型将不会捕获此动态行为。同样，迹线可能仅对特定输入大小有效。")]),t._v(" "),e("p",[t._v("可以"),e("a",{attrs:{href:"https://pytorch.org/docs/master/onnx.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("在文档"),e("OutboundLink")],1),t._v("中找到有关 ONNX 的更多详细信息。")]),t._v(" "),e("p",[t._v("为了能够以 ONNX 格式导出 timm 模型，我们可以在创建模型时使用 exportable_参数_，以确保模型是可追踪的。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/ab7bea1ee10e33ca96127b90e7fb3d30.png",alt:""}})]),t._v(" "),e("p",[t._v("我们现在可以"),e("code",[t._v("torch.onnx.export")]),t._v("用来跟踪和导出我们的模型：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/e4fa2e4f842037c291077ed5fa3a54fe.png",alt:""}})]),t._v(" "),e("p",[e("code",[t._v("check_model")]),t._v("我们现在可以使用该函数验证我们的模型是否有效。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/15ecbd4730eaae048eb8dcb4f021be8c.png",alt:""}})]),t._v(" "),e("p",[t._v("由于我们指定我们的模型应该是可追踪的，因此我们也可以手动执行追踪，如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/4254854a1c74959c923f7009b8e6ddc6.png",alt:""}})]),t._v(" "),e("p",[t._v("timm 包含许多数据增强转换，可以将它们链接在一起以制作增强管道；与 TorchVision 类似，这些管道需要 PIL 图像作为输入。")]),t._v(" "),e("p",[t._v("最简单的入门方法是使用"),e("code",[t._v("create_transform")]),t._v("工厂函数，让我们在下面探讨如何使用它。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/e4a7239d84c7a515ba36076383863263.png",alt:""}})]),t._v(" "),e("p",[t._v("在这里，我们可以看到这已经创建了一些基本的增强管道，包括调整大小、归一化和将图像转换为张量。"),e("em",[t._v("正如我们所料，当我们设置is_training=True_时，我们可以看到额外的转换，例如水平翻转和颜色抖动。这些增强的幅度可以通过_hflip")]),t._v("、_vflip_和_color_jitter_等参数来控制。")]),t._v(" "),e("p",[t._v("我们还可以看到，用于调整图像大小的方法也因我们是否在训练而异。虽然在验证期间使用了标准的_Resize_和_CenterCrop_，但在训练期间使用了_RandomResizedCropAndInterpolation_，下面让我们看看它做了什么。由于 timm 中此变换的实现使我们能够设置不同的图像插值方法；这里我们选择随机选择插值。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/305e2c2bb6f33b0097918a16051ce15f.png",alt:""}})]),t._v(" "),e("p",[t._v("多次运行转换，我们可以观察到图像被截取了不同的裁剪。虽然这在训练过程中是有益的，但这可能会使评估过程中的任务变得更加困难。")]),t._v(" "),e("p",[t._v("根据图像的类型，这种类型的变换可能会导致图片的主题从图像中被裁剪掉；如果我们查看第一行中的第二张图片，我们可以看到一个例子！虽然这不应该是一个大问题，如果它不经常发生，我们可以通过调整 scale 参数来避免这种情况：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/11cf93573d2b1bed81df9867dd921c31.png",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"兰德增幅"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#兰德增幅"}},[t._v("#")]),t._v(" "),e("strong",[t._v("兰德增幅")])]),t._v(" "),e("p",[t._v("开始一项新任务时，可能很难知道要使用哪些增强功能以​​及使用的顺序；随着现在可用的增强数量，组合的数量是巨大的！")]),t._v(" "),e("p",[t._v("通常，一个好的起点是使用在其他任务上表现良好的增强管道。其中一个策略是 RandAugment，这是一种自动数据增强方法，它从一组增强中统一采样操作——例如均衡、旋转、曝光、颜色抖动、色调分离、改变对比度、改变亮度、改变锐度、剪切和平移——并应用其中一些顺序；有关更多信息，请参阅"),e("a",{attrs:{href:"https://arxiv.org/abs/1909.13719",target:"_blank",rel:"noopener noreferrer"}},[t._v("原始论文"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("p",[t._v("然而，timm 中提供的实现有几个关键差异，timm 的创建者 Ross Wightman 在"),e("a",{attrs:{href:"https://arxiv.org/pdf/2110.00476v1.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("ResNets Strike Back 论文"),e("OutboundLink")],1),t._v("的附录中对其进行了最好的描述，我将其解释如下：")]),t._v(" "),e("blockquote",[e("p",[t._v("原始的 RandAugment 规范有两个超参数，M 和 N；其中 M 是失真幅度，N 是对每个图像均匀采样和应用的失真数。RandAugment 的目标是 M 和 N 都是人类可解释的。")]),t._v(" "),e("p",[t._v("然而，[在最初的实现中] M 的情况并非如此。几个增强的尺度向后或不在范围内单调增加，因此增加 M 不会增加所有增强的强度。")])]),t._v(" "),e("p",[t._v("在最初的实现中，虽然一些增强随着 M 的增加而增强，但其他增强会减少或完全删除，这样每个 M 基本上代表自己的策略。")]),t._v(" "),e("blockquote",[e("p",[t._v("timm 中的实现试图通过添加“增加”模式 [默认启用] 来改善这种情况，其中所有增强强度都随幅度增加。")])]),t._v(" "),e("p",[t._v("这使得增加 M 更加直观，因为所有增强现在都应该随着 M 的相应减少/增加而减少/增加强度。")]),t._v(" "),e("blockquote",[e("p",[t._v("[此外，] timm 添加了一个 MSTD 参数，该参数将具有指定标准偏差的高斯噪声添加到每个失真应用的 M 值中。如果 MSTD 设置为“-inf”，则对于每个失真从 0-M 统一采样 M。")]),t._v(" "),e("p",[t._v("在 timm 的 RandAugment 中注意减少对图像均值的影响，归一化参数可以作为参数传递，这样所有可能引入边界像素的增强都可以使用指定的均值，而不是默认为 0 或其他硬编码元组实施。")]),t._v(" "),e("p",[t._v("[最后，] 默认情况下排除 Cutout 以支持单独使用 timm 的随机擦除实现*，这"),e("br"),t._v("\n对增强图像的均值和标准差影响较小。")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://fastai.github.io/timmdocs/RandomErase",target:"_blank",rel:"noopener noreferrer"}},[t._v("*这里详细探讨了"),e("OutboundLink")],1),t._v("timm 中随机擦除的实现。")]),t._v(" "),e("p",[t._v("现在我们了解了 RandAugment 是什么，让我们看看如何在扩充管道中使用它！")]),t._v(" "),e("p",[t._v("在 timm 中，我们使用配置字符串定义 RandAugment 策略的参数；由破折号 ( "),e("code",[t._v("-")]),t._v(")分隔的多个部分组成")]),t._v(" "),e("p",[t._v("第一部分定义了 rand augment 的特定变体（目前仅"),e("code",[t._v("rand")]),t._v("支持）。可以按任何顺序放置的其余部分是：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("m")]),t._v(" ( "),e("em",[t._v("integer")]),t._v(" ): 随机增加的幅度")]),t._v(" "),e("li",[e("strong",[t._v("n")]),t._v("（"),e("em",[t._v("整数")]),t._v("）：每个图像选择的变换操作数，这是可选的，默认设置为 2")]),t._v(" "),e("li",[e("strong",[t._v("mstd (")]),t._v(" "),e("em",[t._v("float")]),t._v(" ): 应用的幅度噪声的标准偏差")]),t._v(" "),e("li",[e("strong",[t._v("mmax")]),t._v("（"),e("em",[t._v("整数")]),t._v("）：将幅度的上限设置为默认值 10 以外的值")]),t._v(" "),e("li",[e("strong",[t._v("w")]),t._v(" ( "),e("em",[t._v("integer")]),t._v(" ): 概率权重指数（影响操作选择的一组权重的指数）")]),t._v(" "),e("li",[e("strong",[t._v("inc")]),t._v(" ( "),e("em",[t._v("bool — {0, 1}")]),t._v(" )：使用严重程度随幅度增加的增强，这是可选的，默认值为 0例如：")]),t._v(" "),e("li",[e("code",[t._v("rand-m9-n3-mstd0.5")]),t._v("：导致 RandAugment 幅度为 9，每个图像 3 个增强，mstd 0.5")]),t._v(" "),e("li",[e("code",[t._v("rand-mstd1-w0")]),t._v("：导致 mstd 1.0，权重 0，默认 magnitude m 为 10，每个图像有 2 个增强")])]),t._v(" "),e("p",[t._v("将配置字符串传递给"),e("code",[t._v("create_transform")]),t._v("，我们可以看到这是由"),e("code",[t._v("RandAugment")]),t._v("对象处理的，我们可以看到所有可用操作的名称：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/2eaeb379adf5597147f44cc801f35939.png",alt:""}})]),t._v(" "),e("p",[t._v("我们还可以使用"),e("code",[t._v("rand_augment_transform")]),t._v("函数创建此对象以在自定义管道中使用，如下所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/6946ea7b951d1c20243d57f196413a70.png",alt:""}})]),t._v(" "),e("p",[t._v("让我们将此策略应用于图像以可视化一些转换。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/023328491c3415c7dc4f0887e194f6f3.png",alt:""}})]),t._v(" "),e("p",[t._v("从这里，我们可以看到使用 RandAugment 给了我们很多图像的变化！")]),t._v(" "),e("h2",{attrs:{id:"cutmix-和混合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cutmix-和混合"}},[t._v("#")]),t._v(" "),e("strong",[t._v("CutMix 和混合")])]),t._v(" "),e("p",[t._v("timm 使用类提供了"),e("a",{attrs:{href:"https://arxiv.org/abs/1905.04899",target:"_blank",rel:"noopener noreferrer"}},[t._v("CutMix"),e("OutboundLink")],1),t._v("和"),e("a",{attrs:{href:"https://arxiv.org/abs/1710.09412",target:"_blank",rel:"noopener noreferrer"}},[t._v("Mixup"),e("OutboundLink")],1),t._v("扩充的灵活实现"),e("code",[t._v("Mixup")]),t._v("；它处理两种增强并提供在它们之间切换的选项。")]),t._v(" "),e("p",[t._v("使用"),e("code",[t._v("Mixup,")]),t._v("我们可以从各种不同的混合策略中进行选择：")]),t._v(" "),e("ul",[e("li",[e("em",[t._v("batch")]),t._v("：CutMix 与 Mixup 选择、lambda 和 CutMix 区域采样按批次执行")]),t._v(" "),e("li",[e("em",[t._v("pair")]),t._v("：混合、lambda 和区域采样在批次中的采样对上执行")]),t._v(" "),e("li",[e("em",[t._v("elem")]),t._v("：混合、lambda 和区域采样在批次内按图像执行")]),t._v(" "),e("li",[e("em",[t._v("half")]),t._v("：与 elementwise 相同，但每个混合对中的一个被丢弃，以便每个样本每个 epoch 看到一次")])]),t._v(" "),e("p",[t._v("让我们想象一下这是如何工作的。为此，我们需要创建一个 DataLoader，遍历它并将扩充应用于批处理。我们将再次使用 Pets 数据集中的图像。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/100c3e897b008f510b74dedf85051a7d.png",alt:""}})]),t._v(" "),e("p",[t._v("使用 TorchVision 和"),e("a",{attrs:{href:"https://fastai.github.io/timmdocs/mixup_cutmix",target:"_blank",rel:"noopener noreferrer"}},[t._v("timmdocs"),e("OutboundLink")],1),t._v("的辅助函数，我们可以在不应用增强的情况下可视化我们批次中的图像：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/9c89c029ba1994adcd4b46a3508a0ec9.png",alt:""}})]),t._v(" "),e("p",[t._v("现在，让我们创建我们的 MixUp 转换！"),e("code",[t._v("Mixup")]),t._v("支持以下参数：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("mixup_alpha")]),t._v(" ( "),e("em",[t._v("float")]),t._v(" ): 混合 alpha 值，如果 > 0 则混合有效，（默认值：1）")]),t._v(" "),e("li",[e("strong",[t._v("cutmix_alpha")]),t._v(" ( "),e("em",[t._v("float")]),t._v(" )：cutmix alpha 值，如果 > 0，则 cutmix 处于活动状态。（默认值：0）")]),t._v(" "),e("li",[e("strong",[t._v("cutmix_minmax")]),t._v(" ( "),e("em",[t._v("List[float]")]),t._v(" )：cutmix 最小/最大图像比率，cutmix 处于活动状态，如果不是 None，则使用此 vs alpha。")]),t._v(" "),e("li",[e("strong",[t._v("prob")]),t._v(" ( "),e("em",[t._v("float")]),t._v(" ): 每个批次或元素应用 mixup 或 cutmix 的概率（默认值：1）")]),t._v(" "),e("li",[e("strong",[t._v("switch_prob")]),t._v(" ( "),e("em",[t._v("float")]),t._v(" )：当两者都处于活动状态时切换到 cutmix 而不是 mixup 的概率（默认值：0.5）")]),t._v(" "),e("li",[e("strong",[t._v("模式")]),t._v("（"),e("em",[t._v("str")]),t._v("）：如何应用 mixup/cutmix 参数（默认值："),e("em",[t._v("batch")]),t._v("）")]),t._v(" "),e("li",[e("strong",[t._v("label_smoothing")]),t._v(" ( "),e("em",[t._v("float")]),t._v(" )：应用于混合目标张量的标签平滑量（默认值：0.1）")]),t._v(" "),e("li",[e("strong",[t._v("num_classes")]),t._v(" ( "),e("em",[t._v("int")]),t._v(" ): 目标变量的类数")])]),t._v(" "),e("p",[t._v("让我们定义一组参数，以便我们将 mixup 或 cutmix 应用于一批图像，并以 1 的概率交替，并使用它们来创建我们的“Mixup”转换：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/2f5de61626a9efcedff1b441b1c71ccf.png",alt:""}})]),t._v(" "),e("p",[t._v("由于 mixup 和 cutmix 发生在一批图像上，我们可以在应用增强之前将批次放在 GPU 上以加快处理速度！在这里，我们可以看到 mixup 已应用于这批图像。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/f1e41d3adbe6e7558e83ad6fa9ec86d9.png",alt:""}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/1dd76acd358a8752c9f8f8757b5e3e88.png",alt:""}})]),t._v(" "),e("p",[t._v("再次运行增强，我们可以看到，这次应用了 CutMix。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/13e5d3ec445131acab9e00a6280baf0f.png",alt:""}})]),t._v(" "),e("p",[t._v("从彼此上方打印的标签中，我们可以观察到我们也可以"),e("code",[t._v("Mixup")]),t._v("用于标签平滑！")]),t._v(" "),e("p",[t._v("timm 提供了许多有用的实用程序来处理不同类型的数据集。最简单的入门方法是使用该"),e("code",[t._v("create_dataset")]),t._v("函数，它将为我们创建一个合适的数据集。")]),t._v(" "),e("p",[e("code",[t._v("create_dataset")]),t._v("总是需要两个参数：")]),t._v(" "),e("ul",[e("li",[e("em",[t._v("name")]),t._v("：我们要加载的数据集的名称")]),t._v(" "),e("li",[t._v("_root：_数据集在本地文件系统上的根文件夹")])]),t._v(" "),e("p",[t._v("但有额外的关键字参数可用于指定选项，例如我们是否要加载训练集或验证集。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/1564d4d64447c358c580680e6b60b23b.png",alt:""}})]),t._v(" "),e("p",[t._v("我们还可以使用"),e("code",[t._v("create_dataset")]),t._v(", 从几个不同的地方加载数据：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://pytorch.org/vision/0.11/datasets.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("TorchVision"),e("OutboundLink")],1),t._v("中可用的数据集"),e("a",{attrs:{href:"https://pytorch.org/vision/0.11/datasets.html",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.tensorflow.org/datasets",target:"_blank",rel:"noopener noreferrer"}},[t._v("TensorFlow 数据"),e("OutboundLink")],1),t._v("集中可用的数据集"),e("a",{attrs:{href:"https://www.tensorflow.org/datasets",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("li",[t._v("存储在本地文件夹中的数据集")])]),t._v(" "),e("p",[t._v("让我们探讨其中的一些选项。")]),t._v(" "),e("h2",{attrs:{id:"从-torchvision-加载数据集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从-torchvision-加载数据集"}},[t._v("#")]),t._v(" 从 TorchVision 加载数据集")]),t._v(" "),e("p",[t._v("要加载 TorchVision 包含的数据集，我们只需"),e("code",[t._v("torch/")]),t._v("在我们希望加载的数据集名称前指定前缀即可。如果数据在文件系统中不存在，我们可以通过设置_download=True_来下载这些数据。此外，我们在这里指定要使用_split_参数加载训练数据集。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/eff2d1687aee390adc20f29369498a50.png",alt:""}})]),t._v(" "),e("p",[t._v("检查类型，我们可以看到这是一个 TorchVision 数据集。我们可以像往常一样使用索引访问它：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/d276415ca7cd02c0ef51b87c98e2f2df.png",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"从-tensorflow-数据集加载数据集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从-tensorflow-数据集加载数据集"}},[t._v("#")]),t._v(" 从 TensorFlow 数据集加载数据集")]),t._v(" "),e("p",[t._v("除了通过 TorchVision 使用 PyTorch 时通常可用的数据集外，timm 还使我们能够从 TensorFlow 数据集下载和使用数据集；为我们包装底层"),e("code",[t._v("tfds")]),t._v("对象。")]),t._v(" "),e("p",[t._v("从 TensorFlow 数据集加载时，建议我们设置几个额外的参数，本地或 TorchVision 数据集不需要这些参数：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("batch_size")]),t._v("：这用于确保批量大小除以分布式训练期间所有节点的样本总数")]),t._v(" "),e("li",[e("strong",[t._v("is_training")]),t._v("：如果设置，数据集将被打乱。请注意，这与设置_拆分不同_")])]),t._v(" "),e("p",[t._v("虽然此包装器从 TFDS 数据集中返回解压缩的图像示例，但我们需要的任何增强和批处理仍由 PyTorch 处理。")]),t._v(" "),e("p",[t._v("在这种情况下，我们在数据集的名称前加上"),e("code",[t._v("tfds/")]),t._v(". 可在"),e("a",{attrs:{href:"https://www.tensorflow.org/datasets/catalog/overview#image_classification",target:"_blank",rel:"noopener noreferrer"}},[t._v("此处"),e("OutboundLink")],1),t._v("找到用于图像分类的可用数据集列表。对于这个例子，我们将任意选择_beans_数据集。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/1faa725947b90933a2b7dd50edf43b21.png",alt:""}})]),t._v(" "),e("p",[t._v("我们还可以看到，对于_split_参数，我们指定了一个"),e("code",[t._v("tfds")]),t._v(" 拆分字符串，如此"),e("a",{attrs:{href:"https://www.tensorflow.org/datasets/splits",target:"_blank",rel:"noopener noreferrer"}},[t._v("处"),e("OutboundLink")],1),t._v("所述。")]),t._v(" "),e("p",[t._v("检查我们的数据集，我们可以看到底层的 TensorFlow 数据集已被包装在一个"),e("code",[t._v("IterableImageDataset")]),t._v("对象中。作为一个可迭代的数据集，它不支持索引——看"),e("a",{attrs:{href:"https://pytorch.org/docs/stable/data.html#dataset-types",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),e("OutboundLink")],1),t._v("的区别——所以为了从这个数据集中查看图像，我们必须首先创建一个迭代器。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/0604ca9d072a23f0102ad554d13d3936.png",alt:""}})]),t._v(" "),e("p",[t._v("我们现在可以使用此迭代器按顺序检查我们的图像和标签，如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/0109145474a642e05e79ee25e2e241c8.png",alt:""}})]),t._v(" "),e("p",[t._v("我们可以看到我们的图片已经正确加载了！")]),t._v(" "),e("h2",{attrs:{id:"从本地文件夹加载数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从本地文件夹加载数据"}},[t._v("#")]),t._v(" 从本地文件夹加载数据")]),t._v(" "),e("p",[t._v("我们还可以从本地文件夹加载数据，在这些情况下，我们只需使用空字符串 ("),e("code",[t._v("''")]),t._v(") 作为数据集名称。")]),t._v(" "),e("p",[t._v("除了能够从 ImageNet 风格的文件夹层次结构中加载之外，"),e("code",[t._v("create_dataset")]),t._v("还可以让我们从一个或多个 tar 存档中提取；我们可以使用它来避免解压缩存档！例如，我们可以在"),e("a",{attrs:{href:"https://github.com/fastai/imagenette",target:"_blank",rel:"noopener noreferrer"}},[t._v("Imagenette 数据集"),e("OutboundLink")],1),t._v("上进行尝试。")]),t._v(" "),e("p",[t._v("此外，到目前为止，我们一直在加载原始图像，所以让我们也使用_transform_参数来应用一些转换；"),e("code",[t._v("create_transform")]),t._v("在这里，我们可以使用我们之前看到的函数快速创建一些合适的转换！")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/28e756e30a826bfbf307d85a7db6a3a9.png",alt:""}})]),t._v(" "),e("p",[t._v("通过检查图像的耻辱，我们可以看到我们的变换已经应用。")]),t._v(" "),e("h2",{attrs:{id:"图像数据集类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图像数据集类"}},[t._v("#")]),t._v(" 图像数据集类")]),t._v(" "),e("p",[t._v("正如我们所见，该"),e("code",[t._v("create_dataset")]),t._v("函数提供了很多选项来处理不同类型的数据。timm 能够提供这种灵活性的原因是在可能的情况下使用 TorchVision 中提供的现有数据集类，并提供一些额外的实现——"),e("code",[t._v("ImageDataset")]),t._v("并且"),e("code",[t._v("IterableImageDataset")]),t._v("可以在广泛的场景中使用。")]),t._v(" "),e("p",[t._v("本质上，"),e("code",[t._v("create_dataset")]),t._v("通过选择合适的类为我们简化了这个过程，但有时我们可能希望直接使用底层组件。")]),t._v(" "),e("p",[t._v("我最常使用的实现是"),e("code",[t._v("ImageDataset")]),t._v("，它类似于"),e("a",{attrs:{href:"https://pytorch.org/vision/main/generated/torchvision.datasets.ImageFolder.html",target:"_blank",rel:"noopener noreferrer"}},[e("em",[t._v("torchvision.datasets.ImageFolder")]),e("OutboundLink")],1),t._v("，但有一些额外的功能。让我们探索如何使用它来加载我们解压缩的 imagenette 数据集。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/2702066f7d8a3489542eaa3dd6a12448.png",alt:""}})]),t._v(" "),e("p",[t._v("的灵活性的关键在于"),e("code",[t._v("ImageDataset")]),t._v("它索引和加载样本的方式被抽象到一个"),e("code",[t._v("Parser")]),t._v("对象中。")]),t._v(" "),e("p",[t._v("timm 包含几个解析器，包括从文件夹、tar 文件和 TensorFlow 数据集读取图像的解析器。解析器可以作为参数传递给数据集，我们可以直接访问解析器。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/ac0ca636ee57b0984c30abebd8047d15.png",alt:""}})]),t._v(" "),e("p",[t._v("在这里，我们可以看到默认的解析器是"),e("code",[t._v("ParserImageFolder")]),t._v(". 解析器还包含有用的信息，例如类查找，我们可以如下所示访问这些信息。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/333c8906ebdd6f38cef024ac93d24d40.png",alt:""}})]),t._v(" "),e("p",[t._v("我们可以看到此解析器已将原始标签转换为整数，可以将其提供给我们的模型。")]),t._v(" "),e("p",[e("strong",[t._v("手动选择解析器——tar 示例")])]),t._v(" "),e("p",[t._v("因此，除了选择合适的类外，"),e("code",[t._v("create_dataset")]),t._v("还负责选择正确的解析器。再次考虑压缩的 Imagenette 数据集，我们可以通过手动选择"),e("code",[t._v("ParserImageInTar")]),t._v("解析器并覆盖"),e("code",[t._v("ImageDataset")]),t._v("的默认解析器来获得相同的结果。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/536c5d1aafa1149f5c3b856c25c5a0ee.png",alt:""}})]),t._v(" "),e("p",[t._v("检查第一个示例，我们可以验证它是否已正确加载。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/cd0d6f7231eead30811ae0e86f1996f3.png",alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("创建自定义解析器")])]),t._v(" "),e("p",[t._v("不幸的是，数据集的结构并不总是像 ImageNet；也就是说，具有以下结构：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("root/class_1/xx1.jpg   \nroot/class_1/xx2.jpg   \nroot/class_2/xx1.jpg   \nroot/class_2/xx2.jpg\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("p",[t._v("对于这些数据集，"),e("code",[t._v("ImageDataset")]),t._v("开箱即用。虽然我们总是可以实现自定义数据集来处理这个问题，但这可能具有挑战性，具体取决于数据的存储方式。另一种选择是编写自定义解析器以与"),e("code",[t._v("ImageDataset")]),t._v(".")]),t._v(" "),e("p",[t._v("例如，让我们考虑"),e("a",{attrs:{href:"https://www.robots.ox.ac.uk/~vgg/data/pets/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Oxford 宠物数据集"),e("OutboundLink")],1),t._v("，其中所有图像都位于一个文件夹中，并且类名（在本例中为每个品种的名称）包含在文件名中。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/3d5a2089f7a50b9e6faddf3641c94bf1.png",alt:""}})]),t._v(" "),e("p",[t._v("在这种情况下，由于我们仍在从本地文件系统加载图像，因此对"),e("code",[t._v("ParserImageFolder")]),t._v(". 让我们看看它是如何实现的以获取灵感。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/9d91c34ab416fc712b7e38abcb87e101.png",alt:""}})]),t._v(" "),e("p",[t._v("从这里，我们可以看到 ParserImageFolder 做了几件事：")]),t._v(" "),e("ul",[e("li",[t._v("为类创建映射")]),t._v(" "),e("li",[t._v("实现"),e("code",[t._v("__len__")]),t._v("返回样本数")]),t._v(" "),e("li",[t._v("实现"),e("code",[t._v("_filename")]),t._v("返回样本的文件名，并带有确定它应该是绝对路径还是相对路径的选项")]),t._v(" "),e("li",[t._v("实现"),e("code",[t._v("__getitem__")]),t._v("返回样本和目标。")])]),t._v(" "),e("p",[t._v("现在我们了解了我们必须实现的方法，我们可以基于此创建我们自己的实现！在这里，我使用了标准库中的"),e("a",{attrs:{href:"https://docs.python.org/3/library/pathlib.html",target:"_blank",rel:"noopener noreferrer"}},[e("em",[t._v("pathlib")]),e("OutboundLink")],1),t._v("来提取类名并处理我们的路径；因为我发现它比"),e("code",[t._v("os")]),t._v(".")]),t._v(" "),e("p",[t._v("我们现在可以将解析器的一个实例传递给"),e("code",[t._v("ImageDataset")]),t._v("，这应该使它能够正确加载宠物数据集！")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/4c4cbf9c5c24fcc01115a524ed900396.png",alt:""}})]),t._v(" "),e("p",[t._v("让我们通过检查第一个示例来验证我们的解析器是否正常工作。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/aa3d2eeac3d5e2ef9c37688990649ece.png",alt:""}})]),t._v(" "),e("p",[t._v("由此看来，我们的解析器似乎成功了！此外，与默认解析器一样，我们可以检查已执行的类映射。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/330608893cfe4b6d9a9690bf2d09a551.png",alt:""}})]),t._v(" "),e("p",[t._v("在这个简单的示例中，创建自定义数据集实现只会稍微多一些努力。但是，希望这有助于说明编写自定义解析器并使其与"),e("code",[t._v("ImageDataset")]),t._v("!")]),t._v(" "),e("p",[t._v("timm 具有大量优化器，其中一些优化器不作为 PyTorch 的一部分提供。除了使访问熟悉的优化器（如"),e("a",{attrs:{href:"https://pytorch.org/docs/stable/generated/torch.optim.SGD.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("SGD"),e("OutboundLink")],1),t._v("、"),e("a",{attrs:{href:"https://pytorch.org/docs/stable/generated/torch.optim.Adam.html#torch.optim.Adam",target:"_blank",rel:"noopener noreferrer"}},[t._v("Adam"),e("OutboundLink")],1),t._v("和"),e("a",{attrs:{href:"https://pytorch.org/docs/stable/generated/torch.optim.AdamW.html#torch.optim.AdamW",target:"_blank",rel:"noopener noreferrer"}},[t._v("AdamW"),e("OutboundLink")],1),t._v(" ）变得容易之外，一些值得注意的内容包括：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("AdamP")]),t._v("："),e("a",{attrs:{href:"https://arxiv.org/abs/2006.08217",target:"_blank",rel:"noopener noreferrer"}},[t._v("在本文中描述"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("strong",[t._v("RMSPropTF")]),t._v("：基于原始 TensorFlow 实现的"),e("a",{attrs:{href:"http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("RMSProp实现，以及"),e("OutboundLink")],1),e("a",{attrs:{href:"https://github.com/pytorch/pytorch/issues/23796",target:"_blank",rel:"noopener noreferrer"}},[t._v("此处讨论的其他小调整"),e("OutboundLink")],1),t._v("。根据我的经验，这通常会导致比 PyTorch 版本更稳定的训练")]),t._v(" "),e("li",[e("strong",[t._v("LAMB ：")]),t._v(" "),e("a",{attrs:{href:"https://nvidia.github.io/apex/optimizers.html#apex.optimizers.FusedLAMB",target:"_blank",rel:"noopener noreferrer"}},[t._v("来自 Apex"),e("OutboundLink")],1),t._v("的 FusedLAMB 优化器的纯 pytorch 变体，在使用 PyTorch XLA 时与 TPU 兼容")]),t._v(" "),e("li",[e("strong",[t._v("AdaBelief")]),t._v("："),e("a",{attrs:{href:"https://arxiv.org/abs/2010.07468",target:"_blank",rel:"noopener noreferrer"}},[t._v("在本文中"),e("OutboundLink")],1),t._v("有描述。"),e("a",{attrs:{href:"https://github.com/juntang-zhuang/Adabelief-Optimizer#quick-guide",target:"_blank",rel:"noopener noreferrer"}},[t._v("此处"),e("OutboundLink")],1),t._v("提供有关设置超参数的指南"),e("a",{attrs:{href:"https://github.com/juntang-zhuang/Adabelief-Optimizer#quick-guide",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("li",[e("strong",[t._v("MADGRAD")]),t._v("："),e("a",{attrs:{href:"https://arxiv.org/abs/2101.11075",target:"_blank",rel:"noopener noreferrer"}},[t._v("在本文中描述"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("strong",[t._v("AdaHessian ：")]),t._v(" "),e("a",{attrs:{href:"https://arxiv.org/abs/2006.00719",target:"_blank",rel:"noopener noreferrer"}},[t._v("本文"),e("OutboundLink")],1),t._v("中描述的自适应二阶优化器"),e("a",{attrs:{href:"https://arxiv.org/abs/2006.00719",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://pytorch.org/docs/stable/optim.html",target:"_blank",rel:"noopener noreferrer"}},[e("em",[t._v("timm 中的优化器支持与torch.optim")]),e("OutboundLink")],1),t._v("中相同的接口，并且在大多数情况下可以简单地放入训练脚本中而无需进行任何更改。")]),t._v(" "),e("p",[t._v("要查看 timm 实现的所有优化器，我们可以检查 timm.optim 模块。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/99d647b8df9edd595deec4649e2ef757.png",alt:""}})]),t._v(" "),e("p",[t._v("创建优化器的最简单方法是使用"),e("code",[t._v("create_optimizer_v2")]),t._v("工厂函数，它需要以下内容：")]),t._v(" "),e("ul",[e("li",[t._v("模型或参数集")]),t._v(" "),e("li",[t._v("优化器的名称")]),t._v(" "),e("li",[t._v("传递给优化器的任何参数")])]),t._v(" "),e("p",[t._v("我们可以使用此函数来创建 timm 中包含的任何优化器实现，以及 torch.optim 中流行的优化器和"),e("a",{attrs:{href:"https://nvidia.github.io/apex/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Apex中的"),e("OutboundLink")],1),e("a",{attrs:{href:"https://nvidia.github.io/apex/optimizers.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("融合优化器"),e("OutboundLink")],1),t._v("（如果已安装）。"),e("a",{attrs:{href:"https://nvidia.github.io/apex/index.html",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("让我们看一些例子。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/5e0bf05042efa68088ed034812a46f05.png",alt:""}})]),t._v(" "),e("p",[t._v("在这里，我们可以看到，由于 timm 不包含 SGD 的实现，它使用 torch.optim 的实现创建了我们的优化器。")]),t._v(" "),e("p",[t._v("让我们尝试创建一个在 timm 中实现的优化器。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/dcf7f173119a5be680b072758f871e37.png",alt:""}})]),t._v(" "),e("p",[t._v("我们可以验证"),e("code",[t._v("Lamb")]),t._v("已经使用了 timm 的实现，并且我们的权重衰减已应用于参数组 1。")]),t._v(" "),e("p",[e("strong",[t._v("手动创建优化器")])]),t._v(" "),e("p",[t._v("当然，如果我们不想使用"),e("code",[t._v("create_optimizer_v2")]),t._v("，所有这些优化器都可以用通常的方式创建。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("优化器 = timm.optim.RMSpropTF(model.parameters(), lr=0.01)\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("h2",{attrs:{id:"使用示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用示例"}},[t._v("#")]),t._v(" 使用示例")]),t._v(" "),e("p",[t._v("现在，我们可以使用其中的大部分优化器，如下所示：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("_\\# 替换  \n\\# optimizer = torch.optim.Adam(model.parameters(), lr=0.01) \\# 用  \n_optimizer = timm.optim.AdamP(model.parameters(), lr=0.01) for epoch in num_epochs:   \n for batch in training_dataloader :   \n inputs, targets = batch   \n outputs = model(inputs)   \n loss = loss_function(outputs, targets) loss.backward()  \n 优化器.step() 优化器.zero_grad(   \n )\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br")])]),e("p",[t._v("在撰写本文时，唯一的例外是二阶"),e("code",[t._v("Adahessian")]),t._v("优化器，它在执行该"),e("code",[t._v("backward")]),t._v("步骤时需要进行一些小的调整；对于将来可能添加的其他二阶优化器，可能需要进行类似的调整。")]),t._v(" "),e("p",[t._v("这在下面进行了演示。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('optimizer = timm.optim.Adahessian(model.parameters(), lr=0.01) is\\_second\\_order = (   \n hasattr(optimizer, **"is\\_second\\_order"** ) and optimizer.is\\_second\\_order   \n) _\\# True_ for epoch in num_epochs:   \n for batch in training_dataloader:   \n inputs, targets =批量  \n 输出 = 模型（输入）  \n 损失 = 损失函数（输出，目标）损失.向后（创建_图形=第二个顺序）优化器 .step（）  \n 优化器.zero_grad（   \n ）\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br")])]),e("h2",{attrs:{id:"展望"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#展望"}},[t._v("#")]),t._v(" 展望")]),t._v(" "),e("p",[t._v("timm 还使我们能够将前瞻算法应用于优化器；"),e("a",{attrs:{href:"https://arxiv.org/abs/1907.08610",target:"_blank",rel:"noopener noreferrer"}},[t._v("在这里介绍并在这里"),e("OutboundLink")],1),t._v("很好"),e("a",{attrs:{href:"https://www.youtube.com/watch?v=TxGxiDK0Ccc",target:"_blank",rel:"noopener noreferrer"}},[t._v("地解释"),e("OutboundLink")],1),t._v("。Lookahead 可以提高学习稳定性并降低其内部优化器的方差，而计算和内存成本可以忽略不计。")]),t._v(" "),e("p",[t._v("我们可以通过在优化器名称前加上前缀来将 Lookahead 应用于优化器"),e("code",[t._v("lookahead_")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("优化器 = timm.optim.create\\_optimizer\\_v2(model.parameters(), opt='lookahead_adam', lr=0.01)\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("或由 timm 的 Lookahead 类中的优化器实例包装：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("timm.optim.Lookahead（优化器，alpha=0.5，k=6）\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("使用 Lookahead 时，我们需要更新我们的训练脚本以包含以下行，以更新慢速权重。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("优化器.sync_lookahead()\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("下面演示了如何使用它的示例：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("optimizer = timm.optim.AdamP(model.parameters(), lr=0.01)   \noptimizer = timm.optim.Lookahead(optimizer) for epoch in num_epochs:   \n for batch in training_dataloader:   \n inputs, targets = batch   \n outputs = model(inputs)   \n loss = loss_function(outputs, targets) loss.backward() optimizer.step()   \n optimizer.zero_grad() optimizer.sync_lookahead()\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br")])]),e("p",[t._v("在撰写本文时，timm 包含以下调度程序：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("StepLRScheduler")]),t._v("：学习率每_n_步衰减一次；类似于"),e("a",{attrs:{href:"https://pytorch.org/docs/stable/generated/torch.optim.lr_scheduler.StepLR.html#torch.optim.lr_scheduler.StepLR",target:"_blank",rel:"noopener noreferrer"}},[t._v("torch.optim.lr_scheduler.StepLR"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("strong",[t._v("MultiStepLRScheduler")]),t._v("：一个步骤调度器，支持降低学习率的多个里程碑；类似于"),e("a",{attrs:{href:"https://pytorch.org/docs/stable/generated/torch.optim.lr_scheduler.MultiStepLR.html#torch.optim.lr_scheduler.MultiStepLR",target:"_blank",rel:"noopener noreferrer"}},[t._v("torch.optim.lr_scheduler.MultiStepLR"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("strong",[t._v("PlateauLRScheduler")]),t._v("：每次达到指定的指标高原时，将学习率降低一个指定的因子；类似于"),e("a",{attrs:{href:"https://pytorch.org/docs/stable/generated/torch.optim.lr_scheduler.ReduceLROnPlateau.html#torch.optim.lr_scheduler.ReduceLROnPlateau",target:"_blank",rel:"noopener noreferrer"}},[t._v("torch.optim.lr_scheduler.ReduceLROnPlateau"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("strong",[t._v("CosineLRScheduler")]),t._v("：余弦衰减调度与重启，如"),e("a",{attrs:{href:"https://arxiv.org/abs/1608.03983",target:"_blank",rel:"noopener noreferrer"}},[t._v("本文"),e("OutboundLink")],1),t._v("所述；类似于"),e("a",{attrs:{href:"https://pytorch.org/docs/stable/generated/torch.optim.lr_scheduler.CosineAnnealingWarmRestarts.html#torch.optim.lr_scheduler.CosineAnnealingWarmRestarts",target:"_blank",rel:"noopener noreferrer"}},[t._v("torch.optim.lr_scheduler.CosineAnnealingWarmRestarts"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("strong",[t._v("TanhLRScheduler")]),t._v("：带重启的双曲正切衰减时间表，如"),e("a",{attrs:{href:"https://arxiv.org/abs/1806.01593",target:"_blank",rel:"noopener noreferrer"}},[t._v("本文所述"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("strong",[t._v("PolyLRScheduler")]),t._v("：多项式衰减时间表，如"),e("a",{attrs:{href:"https://arxiv.org/abs/2004.05909",target:"_blank",rel:"noopener noreferrer"}},[t._v("本文所述"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("虽然 timm 中实现的许多调度程序在 PyTorch 中都有对应的调度程序，但 timm 版本通常具有不同的默认超参数，并提供额外的选项和灵活性；所有 timm 调度程序预热时期，以及可以选择向计划添加随机噪声。此外，"),e("code",[t._v("CosineLRScheduler")]),t._v("和"),e("code",[t._v("PolyLRScheduler")]),t._v("支持称为_k-decay的衰减选项，如此_"),e("a",{attrs:{href:"https://arxiv.org/abs/2004.05909",target:"_blank",rel:"noopener noreferrer"}},[t._v("处"),e("OutboundLink")],1),t._v("介绍。")]),t._v(" "),e("p",[t._v("在检查这些调度程序提供的一些选项之前，让我们首先探讨如何在自定义训练脚本中使用 timm 的调度程序。")]),t._v(" "),e("h2",{attrs:{id:"使用示例-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用示例-2"}},[t._v("#")]),t._v(" 使用示例")]),t._v(" "),e("p",[t._v("与 PyTorch 中包含的调度程序不同，最好每个时期更新两次 timm 调度程序：")]),t._v(" "),e("ul",[e("li",[t._v("该"),e("code",[t._v(".step_update")]),t._v("方法应"),e("strong",[t._v("在每次优化器更新后")]),t._v("调用，并带有_下一次更新_的索引；这是我们调用"),e("code",[t._v(".step")]),t._v("PyTorch 调度程序的地方")]),t._v(" "),e("li",[t._v("该"),e("code",[t._v(".step")]),t._v(" 方法应该"),e("strong",[t._v("在每个纪元结束时")]),t._v("调用，并带有_下一个纪元的索引_")])]),t._v(" "),e("p",[t._v("通过显式提供更新次数和纪元索引，这使 timm 调度程序能够消除在 PyTorch 调度程序中观察到的令人困惑的“last_epoch”和“-1”行为。")]),t._v(" "),e("p",[t._v("下面给出了我们如何使用 timm 调度程序的示例：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("training_epochs = 300   \ncooldown_epochs = 10   \nnum\\_epochs = training\\_epochs + cooldown_epochs optimizer = timm.optim.AdamP(my_model.parameters(), lr=0.01)   \nscheduler = timm.scheduler.CosineLRScheduler(optimizer, t\\_initial=training\\_epochs)范围内的纪元（num_epochs） : num\\_steps\\_per\\_epoch = len(train\\_dataloader)   \n num\\_updates = epoch * num\\_steps\\_per\\_epochfor batch in training_dataloader:   \n inputs, targets = batch   \n outputs = model(inputs)   \n loss = loss_function(outputs, targets)loss.backward()   \n optimizer.step()   \n scheduler.step\\_update( num\\_updates=num_updates) optimizer.zero_grad() scheduler.step（时代+ 1）\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br")])]),e("h2",{attrs:{id:"调整学习率计划"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#调整学习率计划"}},[t._v("#")]),t._v(" 调整学习率计划")]),t._v(" "),e("p",[t._v("为了演示 timm 提供的一些选项，让我们探索一些可用的超参数，以及修改这些参数如何影响学习率计划。")]),t._v(" "),e("p",[t._v("在这里，我们将重点关注"),e("code",[t._v("CosineLRScheduler")]),t._v("，因为这是 timm 训练脚本中默认使用的调度程序。然而，如上所述，在上面列出的所有调度程序中都存在诸如添加预热和噪音等功能。")]),t._v(" "),e("p",[t._v("为了使学习率计划可视化，让我们定义一个函数来创建模型和优化器以与我们的计划程序一起使用。请注意，由于我们只会更新调度程序，模型实际上并没有被优化，但我们需要一个优化器实例来与我们的调度器一起工作，而优化器需要一个模型。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("def create\\_model\\_and_optimizer():   \n model = torch.nn.Linear(2, 1)   \n optimizer = torch.optim.SGD(model.parameters(), lr=0.05)  \n 返回模型，优化器\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("p",[e("strong",[t._v("使用 PyTorch 的“CosineAnnealingWarmRestarts”调度程序")])]),t._v(" "),e("p",[t._v("为了说明 timm 的余弦调度器与 PyTorch 中包含的调度器的不同，让我们首先看看我们将如何使用"),e("code",[t._v("ConsineAnnealingWarmRestarts")]),t._v(".")]),t._v(" "),e("p",[t._v("此类支持以下参数：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("T_0")]),t._v(" ( "),e("em",[t._v("int")]),t._v(" )：第一次重启的迭代次数。")]),t._v(" "),e("li",[e("strong",[t._v("T_mult")]),t._v(" ( "),e("em",[t._v("int")]),t._v(" )：重启后增加_T_{i}的一个因素。_（默认值：`1`）")]),t._v(" "),e("li",[e("strong",[t._v("eta_min")]),t._v(" ( "),e("em",[t._v("float")]),t._v(" ): 最小学习率。（默认值：`0.`）")]),t._v(" "),e("li",[e("strong",[t._v("last_epoch")]),t._v(" ( "),e("em",[t._v("int")]),t._v(" ) — 最后一个纪元的索引。（默认值："),e("code",[t._v("-1")]),t._v("）")])]),t._v(" "),e("p",[t._v("要设置我们的时间表，我们需要定义以下内容：epoch 的数量、每个 epoch 发生的更新次数，以及——如果我们想要启用重新启动——学习率应该返回到它的步数初始值。因为我们在这里不使用任何数据，所以我们可以任意设置这些。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("num_epochs=300   \nnum\\_epoch\\_repeat = num_epochs//2   \nnum\\_steps\\_per_epoch = 10\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("p",[e("strong",[t._v("注意")]),t._v("：在这里，我们指定我们希望学习率在训练运行的中途“重新启动”。这主要是出于可视化目的而选择的——这样我们就可以了解这个调度器的重启是什么样子的——而不是在真正的训练运行中推荐使用这个调度器的方式。")]),t._v(" "),e("p",[t._v("现在，让我们创建我们的学习率调度器。由于_T_0_需要根据迭代次数指定第一次重启之前的时间——其中每次迭代都是一个批次——我们通过将我们希望重启发生的纪元的索引乘以步数来计算每个时代。在这里，我们还指定学习率不应低于 1e-6。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/d0e5932d6e4524d9966512f7f5f51a56.png",alt:""}})]),t._v(" "),e("p",[t._v("现在，我们可以在训练循环中模拟使用这个调度程序。由于我们使用的是 PyTorch 实现，我们只需要"),e("code",[t._v("step")]),t._v("在每次优化器更新后调用，每批一次。在这里，我们记录了每一步后的学习率值，这样我们就可以直观地看到在整个训练过程中学习率值是如何调整的。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/1d568d19c5cf6b18fc5c68e64a4b9cdb.png",alt:""}})]),t._v(" "),e("p",[t._v("从这个图中，我们可以看到学习率一直衰减到第 150 轮，此时它被重置为初始值，然后再次衰减；正如我们所料。")]),t._v(" "),e("p",[e("strong",[t._v("使用 timm 的 `CosineLRScheduler` 调度器")])]),t._v(" "),e("p",[t._v("现在我们了解了如何使用 PyTorch 的余弦调度程序，让我们探讨一下它与 timm 中包含的实现以及提供的其他选项的比较。首先，让我们使用 timm 的余弦学习率调度程序实现来复制之前的情节 — "),e("code",[t._v("CosineLRScheduler")]),t._v("。")]),t._v(" "),e("p",[t._v("我们需要这样做的一些参数与我们之前看到的类似：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("t_initial")]),t._v(" ( "),e("em",[t._v("int")]),t._v(" ): 第一次重启的迭代次数，相当于torch实现中的T_0")]),t._v(" "),e("li",[e("strong",[t._v("lr_min")]),t._v(" ( "),e("em",[t._v("float")]),t._v(" ): 最小学习率，相当于torch 实现中的"),e("strong",[t._v("eta_min")]),t._v(" (默认: `0.`)")]),t._v(" "),e("li",[e("strong",[t._v("cycle_mul")]),t._v(" ( "),e("em",[t._v("float")]),t._v(" ): 重启后增加_T_{i}_的一个因素，这相当于torch 实现中的"),e("strong",[t._v("T_mult")]),t._v("（默认值：`1`）")])]),t._v(" "),e("p",[t._v("然而，为了观察与 Torch 一致的行为，我们还需要设置：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("cycle_limit")]),t._v(" ( "),e("em",[t._v("int")]),t._v(" ): 限制一个周期内重启的次数（默认值：`1`）")]),t._v(" "),e("li",[e("strong",[t._v("t_in_epochs")]),t._v(" ( "),e("em",[t._v("bool")]),t._v(" ): 迭代次数是否以纪元而不是批量更新的次数给出（默认值：`True`）")])]),t._v(" "),e("p",[t._v("首先，让我们定义与之前相同的时间表。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("num_epochs=300   \nnum\\_epoch\\_repeat = num_epochs/2   \nnum\\_steps\\_per_epoch = 10\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("p",[t._v("现在，我们可以创建我们的调度程序实例。在这里，我们用更新步数来表示迭代次数，并将循环限制增加到超过我们期望的重启次数；因此参数与我们之前在 torch 的实现中使用的参数相同。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/a90a8014b07547ff5c2881417de9c9e3.png",alt:""}})]),t._v(" "),e("p",[t._v("现在，让我们定义一个新函数来模拟在训练运行中使用 timm 调度程序并记录学习率的更新。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('def plot\\_lrs\\_for\\_timm\\_scheduler(scheduler): lrs   \n = \\[\\]for epoch in range(num_epochs):   \n num\\_updates = epoch * num\\_steps\\_per\\_epochfor i in range(num\\_steps\\_per_epoch):   \n num_updates += 1   \n scheduler.step\\_update(num\\_updates=num_updates) scheduler.step(epoch + 1 ) lrs.append(optimizer.param_groups\\[0\\]\\[ **"lr"** \\]) plt.plot(lrs)\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br")])]),e("p",[t._v("我们现在可以用它来绘制我们的学习率时间表！")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/60cf385ceda21f489c38f2dc3acd6756.png",alt:""}})]),t._v(" "),e("p",[t._v("正如预期的那样，我们的图表看起来与我们之前看到的相同。")]),t._v(" "),e("p",[t._v("现在我们已经复制了我们在 torch 中看到的行为，让我们更详细地看看 timm 提供的一些附加功能。")]),t._v(" "),e("p",[t._v("到目前为止，我们已经用优化器更新来表示迭代次数；这要求我们计算第一次重复的迭代次数，"),e("code",[t._v("num_epoch_repeat * num_steps_per_epoch")]),t._v("但是，通过根据纪元指定我们的迭代——这是 timm 中的默认值——我们可以避免必须进行此计算。使用默认设置，我们可以简单地传递我们希望第一次重启发生的纪元索引，如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/6c4cbcb18ffe8f8a4680166ab8602c68.png",alt:""}})]),t._v(" "),e("p",[t._v("我们可以看到我们的时间表没有改变，我们只是稍微不同地表达了我们的论点。")]),t._v(" "),e("p",[e("strong",[t._v("添加预热和噪音")])]),t._v(" "),e("p",[t._v("所有 timm 优化器的另一个特点是，它们支持向学习率计划添加预热和噪声。_我们可以使用warmup_t_和_warmup_lr_init_参数指定预热时期的数量，以及预热期间要使用的初始学习率。让我们看看如果我们指定我们想要 20 个预热阶段，我们的时间表会如何变化。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/ac00ed97827ceff6af607041f7f88344.png",alt:""}})]),t._v(" "),e("p",[t._v("在这里，我们可以看到这导致我们的最小学习率逐渐增加，而不是像我们之前看到的那样从那个点开始。")]),t._v(" "),e("p",[t._v("_我们还可以使用noise_range_t_和_noise_pct_参数向一系列时期添加噪声。让我们在前 150 个纪元中添加少量噪声：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/3fb7094842ff6491b83b9055d5db08bf.png",alt:""}})]),t._v(" "),e("p",[t._v("我们可以看到，直到第 150 轮，添加的噪声会影响我们的时间表，因此学习率不会以平滑的曲线下降。_我们可以通过增加noise_pct_来使其更加极端。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/5dda3e41f04b530e347fcccbecb8d724.png",alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("`CosineLRScheduler` 的附加选项")])]),t._v(" "),e("p",[t._v("虽然热身和噪声可以与任何调度程序一起使用，但还有一些特定于"),e("code",[t._v("CosineLRScheduler")]),t._v(". 让我们探讨一下这些如何影响我们的学习率周期。")]),t._v(" "),e("p",[t._v("我们可以使用_cycle_mul_来增加下一次重启之前的时间，如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/50b1af5d752a409755b299becf5ef43f.png",alt:""}})]),t._v(" "),e("p",[t._v("此外，timm 提供了使用_cycle_limit_限制重启次数的选项。默认情况下，它设置为“1”，这会产生以下计划。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/d9a399022ea59747d47f3771911adc7b.png",alt:""}})]),t._v(" "),e("p",[e("code",[t._v("CosineLRScheduler")]),t._v("还支持不同类型的衰减。我们可以使用_cycle_decay_来减少（或增加）将在每次连续重启期间设置的学习率的值。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/940da38f5479bb28d7e2bf72d3bf7bc6.png",alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("注意")]),t._v("：这里我们增加了重启次数的频率，以更好地说明衰减。")]),t._v(" "),e("p",[t._v("为了控制曲线本身，我们可以使用_k_decay_参数，学习率的变化率由其 k 阶导数改变，如"),e("a",{attrs:{href:"https://arxiv.org/abs/2004.05909",target:"_blank",rel:"noopener noreferrer"}},[t._v("本文"),e("OutboundLink")],1),t._v("所述。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/e1f9102c1e5bac9c1c6d1ea5eaddf18e.png",alt:""}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/1eebd0519d69182c4f8880a09940ce7d.png",alt:""}})]),t._v(" "),e("p",[t._v("此选项提供了对该调度程序执行的退火的更多控制！")]),t._v(" "),e("p",[e("strong",[t._v("timm 训练脚本中的默认设置")])]),t._v(" "),e("p",[t._v("如果我们使用 timm 训练脚本中的默认设置来设置此调度程序，我们将观察到以下时间表。")]),t._v(" "),e("p",[e("strong",[t._v("注意")]),t._v("：在训练脚本中，训练继续进行额外的 10 个时期，而没有进一步修改学习率作为“冷却”。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/6fe16f5e5db2db9b6ca193187f88a434.png",alt:""}})]),t._v(" "),e("p",[t._v("正如我们所看到的，默认设置根本没有重启！")]),t._v(" "),e("p",[e("strong",[t._v("其他学习率时间表")])]),t._v(" "),e("p",[t._v("虽然我最喜欢 timm 包含的调度程序"),e("code",[t._v("CosineLRScheduler")]),t._v("，但可视化其他一些调度程序的调度可能会有所帮助，这些调度程序在 PyTorch 中没有对应的调度程序。这两个调度器都类似于余弦调度器，因为学习率在指定数量的 epoch 后重置——假设没有设置循环限制——但退火的方式略有不同。")]),t._v(" "),e("p",[t._v("对于"),e("code",[t._v("TanhLRScheduler")]),t._v("，使用双曲正切函数执行退火，如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/892e76e525715d04d3d53e47f80a367d.png",alt:""}})]),t._v(" "),e("p",[t._v("timm 还提供"),e("code",[t._v("PolyLRScheduler")]),t._v("，它使用多项式衰减：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/504b22a8f03c367a0a900e48772d9f27.png",alt:""}})]),t._v(" "),e("p",[t._v("与 类似"),e("code",[t._v("CosineLRScheduler")]),t._v("，"),e("code",[t._v("PolyLRScheduler")]),t._v("调度程序也支持_k_decay_参数，如下所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/cde5b6646c35e60eb61931771243560f.png",alt:""}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/c8a2fe85d7dc3d2e0530b807d964c74f.png",alt:""}})]),t._v(" "),e("p",[t._v("训练模型时，通过对在整个训练运行中观察到的参数取移动平均值来设置模型权重值可能是有益的，而不是使用上次增量更新后获得的参数。在实践中，这通常是通过维护_EMA 模型_来完成的，该模型是我们正在训练的模型的副本。然而，我们不是在每个更新步骤后更新该模型的所有参数，而是使用现有参数值和更新值的线性组合来设置这些参数。这是使用以下公式完成的：")]),t._v(" "),e("blockquote",[e("p",[t._v("updated_EMA_model_weights =")]),t._v(" "),e("p",[t._v("衰减 * EMA_model_weights + (1. — 衰减) * updated_model_weights")])]),t._v(" "),e("p",[t._v("其中 _decay_ 是我们设置的参数。例如，如果我们设置_decay=0.99_，我们有：")]),t._v(" "),e("blockquote",[e("p",[t._v("updated_EMA_model_weights =")]),t._v(" "),e("p",[t._v("0.99 * EMA_model_weights + 0.01 * updated_model_weights")])]),t._v(" "),e("p",[t._v("我们可以看到保留了 99% 的现有状态，只保留了 1% 的新状态！")]),t._v(" "),e("p",[t._v("为了理解为什么这可能是有益的，让我们考虑一下我们的模型在训练的早期阶段在一批数据上表现异常糟糕的情况。这可能会导致对我们的参数进行大量更新，过度补偿所获得的高损失，这将对即将到来的批次产生不利影响。通过仅包含一小部分最新参数，大型更新将被“平滑”，并且对模型权重的总体影响较小。")]),t._v(" "),e("p",[t._v("有时，这些平均参数有时可以在评估过程中产生明显更好的结果，并且这种技术已被用于多种流行模型的训练方案中，例如训练"),e("a",{attrs:{href:"https://arxiv.org/abs/1807.11626v3",target:"_blank",rel:"noopener noreferrer"}},[t._v("MNASNet"),e("OutboundLink")],1),t._v("、"),e("a",{attrs:{href:"https://arxiv.org/abs/1905.02244v5",target:"_blank",rel:"noopener noreferrer"}},[t._v("MobileNet-V3"),e("OutboundLink")],1),t._v("和"),e("a",{attrs:{href:"https://arxiv.org/abs/1905.11946v5",target:"_blank",rel:"noopener noreferrer"}},[t._v("EfficientNet"),e("OutboundLink")],1),t._v("；使用"),e("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/train/ExponentialMovingAverage",target:"_blank",rel:"noopener noreferrer"}},[t._v("TensorFlow 中包含的实现"),e("OutboundLink")],1),t._v("。使用"),e("code",[t._v("ModelEmaV2")]),t._v("timm 中实现的模块，我们可以复制此行为，并将相同的做法应用于我们自己的训练脚本。")]),t._v(" "),e("p",[t._v("的实现"),e("code",[t._v("ModelEmaV2")]),t._v("需要以下参数：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("model")]),t._v("：我们正在训练的_nn.Module的子类。_这是将在我们的训练循环中正常更新的模型")]),t._v(" "),e("li",[e("strong",[t._v("decay")]),t._v("：（"),e("em",[t._v("float")]),t._v("）要使用的衰减量，它决定了将保持多少先前的状态。TensorFlow 文档建议衰减的合理值接近 1.0，通常在多个 9 范围内：0.999、0.9999 等（默认值：“0.9999”）")]),t._v(" "),e("li",[e("strong",[t._v("device")]),t._v("：应用于评估 EMA 模型的设备。如果未设置，则将在用于模型的同一设备上创建 EMA 模型。")])]),t._v(" "),e("p",[t._v("让我们探索如何将其纳入训练循环。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("model = create\\_model().to(gpu\\_device)   \nema_model = ModelEmaV2(model, decay=0.9998) for epoch in num_epochs:   \n for batch in training_dataloader:   \n inputs, targets = batch   \n outputs = model(inputs)   \n loss = loss_function(outputs, targets) 损失.backward()   \n optimizer.step()   \n optimizer.zero_grad() model_ema.update(model) for batch in validation_dataloader:   \n inputs, targets = batch   \n outputs = model(inputs)   \n validation\\_loss = loss\\_function(outputs, targets) ema\\_model\\_outputs = model_ema.module(输入）  \n ema\\_model\\_validation\\_loss = loss\\_function（ema\\_model\\_outputs，目标）\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br")])]),e("p",[t._v("正如我们所见，要更新 EMA 模型的参数，我们需要"),e("code",[t._v(".update")]),t._v("在每次参数更新后调用。由于 EMA 模型与正在训练的模型有不同的参数，我们必须单独对其进行评估。")]),t._v(" "),e("p",[t._v("重要的是要注意这个类对其初始化的位置很敏感。在分布式训练期间，应该在转换为_SyncBatchNorm_之前和使用_DistributedDataParallel_包装器之前应用它！")]),t._v(" "),e("p",[t._v("此外，在保存 EMA 模型时，_state_dict_中的键将与正在训练的模型中的键相同，因此应使用不同的检查点！")]),t._v(" "),e("p",[t._v("虽然本文中的伪代码片段说明了如何在训练循环中单独使用每个组件，但让我们探索一个我们同时使用许多不同组件的示例！")]),t._v(" "),e("p",[t._v("在这里，我们将着眼于在 Imagenette 上训练模型。请注意，由于 Imagenette 是 Imagenet 的一个子集，如果我们使用预训练模型，我们会稍微作弊，因为只有新的分类头会使用随机权重进行初始化；因此，在这个例子中，我们将从头开始训练。")]),t._v(" "),e("p",[e("strong",[t._v("注意：")]),t._v(" 此示例的目的是演示如何一起使用来自 timm 的多个组件。因此，所选择的特征——以及使用的超参数——在某种程度上是任意选择的；所以通过一些仔细的调整可能会提高性能！")]),t._v(" "),e("p",[t._v("要删除我们通常在 PyTorch 训练循环中看到的样板文件，例如遍历 DataLoader 和在设备之间移动数据，我们将使用 PyTorch 加速来处理我们的训练；这使我们能够仅关注使用 timm 组件时所需的差异。")]),t._v(" "),e("p",[e("em",[t._v("如果您不熟悉 PyTorch 加速，并且想在深入阅读本文之前了解更多相关信息，请查看")]),e("a",{attrs:{href:"https://medium.com/@chris.p.hughes10/introducing-pytorch-accelerated-6ba99530608c?source=friends_link&sk=868c2d2ec5229fdea42877c0bf82b968",target:"_blank",rel:"noopener noreferrer"}},[e("em",[t._v("介绍性博客文章")]),e("OutboundLink")],1),e("em",[t._v("或")]),e("a",{attrs:{href:"https://pytorch-accelerated.readthedocs.io/en/latest/index.html#",target:"_blank",rel:"noopener noreferrer"}},[e("em",[t._v("文档")]),e("OutboundLink")],1),e("em",[t._v("；或者，它非常简单，缺乏这方面的知识不应影响您对此处探讨的内容的理解！")])]),t._v(" "),e("p",[t._v("在 PyTorch 加速中，训练循环由 Trainer 类处理；我们可以在其中覆盖特定方法以更改某些步骤的行为。在伪代码中，在 PyTorch 加速训练器中执行训练可以描述为：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('train_dl =**创建**  \n_训练数据 加载**器**（ ）_ **_** _ **_** _        _         _         _ batch_output)         backward\\_step(batch\\_output\\["loss"\\])         optimizer_step()         scheduler_step()         optimizer\\_zero\\_grad()     train\\_epoch\\_end()     on\\_train\\_epoch_end()  \n  \n  \n  \n  \n      \n  \n  \n  \n  \n  \n  \n  \n  \n eval\\_epoch\\_start    ( )   \n on\\_eval\\_epoch_start        (     )  \n    **对于**eval_dl**中**的批处理： _    _     _  \n  \n  \n  \n  \n  \n  \n\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br"),e("span",{staticClass:"line-number"},[t._v("20")]),e("br"),e("span",{staticClass:"line-number"},[t._v("21")]),e("br"),e("span",{staticClass:"line-number"},[t._v("22")]),e("br"),e("span",{staticClass:"line-number"},[t._v("23")]),e("br"),e("span",{staticClass:"line-number"},[t._v("24")]),e("br"),e("span",{staticClass:"line-number"},[t._v("25")]),e("br")])]),e("p",[t._v("有关 Trainer 如何工作的更多详细信息，请"),e("a",{attrs:{href:"https://pytorch-accelerated.readthedocs.io/en/latest/trainer.html#",target:"_blank",rel:"noopener noreferrer"}},[t._v("参阅文档"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("p",[t._v("我们可以将默认训练器子类化，并在训练脚本中使用它，如下所示：")]),t._v(" "),e("p",[t._v("在使用 2 个 GPU 的 Imagenette 上使用这个训练脚本，"),e("a",{attrs:{href:"https://pytorch-accelerated.readthedocs.io/en/latest/quickstart.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("按照此处的说明"),e("OutboundLink")],1),t._v("，我获得了以下指标：")]),t._v(" "),e("ul",[e("li",[e("em",[t._v("精度")]),t._v("：0.89")]),t._v(" "),e("li",[e("em",[t._v("ema_model_accuracy")]),t._v("：0.85")])]),t._v(" "),e("p",[t._v("34 个纪元后；考虑到尚未调整超参数，这还不错！")]),t._v(" "),e("p",[t._v("希望这对 timm 中包含的某些功能以及如何将这些功能应用于自定义培训脚本提供了一些全面的概述。")]),t._v(" "),e("p",[t._v("最后，我想花点时间感谢 timm 的创建者 Ross Wightman 为创建这个很棒的库所付出的巨大努力。Ross 致力于提供最先进的计算机视觉模型的实现，让整个数据科学界都可以轻松访问这些模型，这是首屈一指的。如果您还没有，请去添加星星！")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://gist.github.com/Chris-hughes10/a9e5ec2cd7e7736c651bf89b5484b4a9",target:"_blank",rel:"noopener noreferrer"}},[e("strong",[t._v("复制这篇文章所需的所有代码都可以在此处")]),e("OutboundLink")],1),t._v("作为 GitHub 要点获得。")]),t._v(" "),e("p",[e("em",[t._v("Chris Hughes 在")]),e("a",{attrs:{href:"http://www.linkedin.com/in/chris-hughes1/",target:"_blank",rel:"noopener noreferrer"}},[e("em",[t._v("LinkedIn")]),e("OutboundLink")],1),e("em",[t._v("上。")])]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/rwightman/pytorch-image-models",target:"_blank",rel:"noopener noreferrer"}},[t._v("rwightman/pytorch-image-models：PyTorch 图像模型、脚本、预训练权重——ResNet、ResNeXT、EfficientNet、EfficientNetV2、NFNet、Vision Transformer、MixNet、MobileNet-V3/V2、RegNet、DPN、CSPNet 等（github.com） )"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://medium.com/paperswithcode/papers-with-code-2021-a-year-in-review-de75d5a77b8b",target:"_blank",rel:"noopener noreferrer"}},[t._v("代码 2021 论文：回顾一年 | 通过猫王 | 代码论文 | 2021 年 12 月 | 中等的"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.image-net.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ImageNet (image-net.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://rwightman.github.io/pytorch-image-models/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Pytorch 图像模型 (rwightman.github.io)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://fastai.github.io/timmdocs/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Pytorch 图像模型 (timm) | timmdocs (fastai.github.io)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://paperswithcode.com/lib/timm",target:"_blank",rel:"noopener noreferrer"}},[t._v("PyTorch 图像模型 | 代码论文"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/1812.01187",target:"_blank",rel:"noopener noreferrer"}},[t._v("[1812.01187] 使用卷积神经网络进行图像分类的技巧包 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/2010.11929v2",target:"_blank",rel:"noopener noreferrer"}},[t._v("[2010.11929v2] 一幅图像值得 16x16 个单词：用于大规模图像识别的变换器 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://ieeexplore.ieee.org/document/8099589",target:"_blank",rel:"noopener noreferrer"}},[t._v("用于对象检测的特征金字塔网络 | IEEE 会议出版物 | IEEE探索"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.robots.ox.ac.uk/~vgg/data/pets/",target:"_blank",rel:"noopener noreferrer"}},[t._v("视觉几何组——牛津大学"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://pytorch.org/vision/stable/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("torchvision — Torchvision 0.11.0 文档 (pytorch.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://pytorch.org/docs/stable/fx.html#module-torch.fx",target:"_blank",rel:"noopener noreferrer"}},[t._v("torch.fx — PyTorch 1.10.1 文档"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://pytorch.org/blog/FX-feature-extraction-torchvision/",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用 Torch FX 在 TorchVision 中进行特征提取 | 火炬"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://pytorch.org/docs/stable/jit.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("TorchScript — PyTorch 1.10.1 文档"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://pytorch.org/tutorials/beginner/Intro_to_TorchScript_tutorial.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("TorchScript 简介 — PyTorch Tutorials 1.10.1+cu102 文档"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://onnx.ai/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ONNX | 家"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://pytorch.org/docs/master/onnx.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("torch.onnx — PyTorch 大师文档"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/1909.13719",target:"_blank",rel:"noopener noreferrer"}},[t._v("[1909.13719] RandAugment：具有减少搜索空间的实用自动数据扩充（arxiv.org）"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/2110.00476v1#:~:text=ResNet%20strikes%20back%3A%20An%20improved%20training%20procedure%20in,or%20as%20baselines%20when%20new%20architectures%20are%20proposed.",target:"_blank",rel:"noopener noreferrer"}},[t._v("[2110.00476v1] ResNet 反击：改进的 timm 训练程序 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/1905.04899",target:"_blank",rel:"noopener noreferrer"}},[t._v("[1905.04899] CutMix：训练具有可本地化特征的强分类器的正则化策略 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/1710.09412",target:"_blank",rel:"noopener noreferrer"}},[t._v("[1710.09412] 混淆：超越经验风险最小化（arxiv.org）"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://pytorch.org/vision/0.11/datasets.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("torchvision.datasets — Torchvision 0.11.0 文档 (pytorch.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.tensorflow.org/datasets",target:"_blank",rel:"noopener noreferrer"}},[t._v("TensorFlow 数据集"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://pytorch.org/docs/stable/data.html#dataset-types",target:"_blank",rel:"noopener noreferrer"}},[t._v("torch.utils.data — PyTorch 1.10.1 文档"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://docs.python.org/3/library/pathlib.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("pathlib — 面向对象的文件系统路径 — Python 3.10.2 文档"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://pytorch.org/docs/stable/optim.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("torch.optim — PyTorch 1.10.1 文档"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/2006.08217",target:"_blank",rel:"noopener noreferrer"}},[t._v("[2006.08217] AdamP：在尺度不变权重上减缓动量优化器的减速 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("lecture_slides_lec6.pdf (toronto.edu)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://nvidia.github.io/apex/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Apex（PyTorch 扩展）— Apex 0.1.0 文档 (nvidia.github.io)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/2010.07468",target:"_blank",rel:"noopener noreferrer"}},[t._v("[2010.07468] AdaBelief 优化器：根据观察到的梯度调整步长 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/juntang-zhuang/Adabelief-Optimizer#quick-guide",target:"_blank",rel:"noopener noreferrer"}},[t._v("juntang-zhuang/Adabelief-Optimizer：NeurIPS 2020 Spotlight 的存储库“AdaBelief Optimizer：根据观察到的梯度调整步长”(github.com)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/2101.11075",target:"_blank",rel:"noopener noreferrer"}},[t._v("[2101.11075] 不妥协的适应性：一种用于随机优化的动量化、自适应、双平均梯度法 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/2006.00719",target:"_blank",rel:"noopener noreferrer"}},[t._v("[2006.00719] ADAHESSIAN：机器学习的自适应二阶优化器 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/1907.08610",target:"_blank",rel:"noopener noreferrer"}},[t._v("[1907.08610] 前瞻优化器：前进 k 步，后退 1 步（arxiv.org）"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.youtube.com/watch?v=TxGxiDK0Ccc",target:"_blank",rel:"noopener noreferrer"}},[t._v("前瞻优化器：前进 k 步，后退 1 步 | Michael Zhang——YouTube"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://pytorch.org/docs/stable/optim.html#how-to-adjust-learning-rate",target:"_blank",rel:"noopener noreferrer"}},[t._v("torch.optim — PyTorch 1.10.1 文档"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/1806.01593",target:"_blank",rel:"noopener noreferrer"}},[t._v("[1806.01593] 分类上具有双曲正切衰减的随机梯度下降 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/2004.05909",target:"_blank",rel:"noopener noreferrer"}},[t._v("[2004.05909] k-decay：学习率调度的新方法 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/1807.11626v3",target:"_blank",rel:"noopener noreferrer"}},[t._v("[1807.11626v3] MnasNet：面向移动设备的平台感知神经架构搜索 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/1905.11946v5",target:"_blank",rel:"noopener noreferrer"}},[t._v("[1905.11946v5] EfficientNet：重新思考卷积神经网络的模型缩放 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://arxiv.org/abs/1905.02244v5",target:"_blank",rel:"noopener noreferrer"}},[t._v("[1905.02244v5] 搜索 MobileNetV3 (arxiv.org)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/train/ExponentialMovingAverage",target:"_blank",rel:"noopener noreferrer"}},[t._v("tf.train.指数移动平均 | TensorFlow 核心 v2.7.0"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://towardsdatascience.com/introducing-pytorch-accelerated-6ba99530608c",target:"_blank",rel:"noopener noreferrer"}},[t._v("介绍 PyTorch 加速 | 通过克里斯休斯 | 2021 年 11 月 | 迈向数据科学"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://pytorch-accelerated.readthedocs.io/en/latest/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("欢迎使用 pytorch-accelerated 的文档！— pytorch 加速 0.1.3 文档"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=n.exports}}]);